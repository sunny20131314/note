# 正则表达式
1. <a name="function"></a><a href="#define"> 定义 </a>
2. <a href="#RegExpGrammar"> 创建 RegExp 对象的语法：</a>
3. <a href="#RegExpAttr"> RegExp 对象属性</a>
4. <a href="#RegExpFn"> RegExp 对象方法</a> 


<a href="#String">支持正则表达式的 String 对象的方法</a>
<a href="#execOrMatch">exec与match的异同</a> 


[作用](#function)
[哪些需要替换](#replace)
<a href="#execOrMatch">exec与match的异同</a>


##  <a name="define"></a><a name="function"></a><a href="#define"> 定义 </a>
正则表达式(regular expression)描述了一种字符串匹配的`模式`，可以用来检查一个串是否含有某种子串、将匹配的子串做替换或者从某个串中取出符合某个条件的子串等。
> 正则表达式是由普通字符（例如字符 a 到 z）以及特殊字符（称为"元字符"）组成的文字模式。模式描述在搜索文本时要匹配的一个或多个字符串。正则表达式作为一个模板，将某个字符
模式与所搜索的字符串进行匹配。


##  <a href="#RegExpGrammar"> 创建 RegExp 对象的语法：</a><a name="RegExpGrammar"></a>
new RegExp(pattern, attributes);
参数 pattern 是一个字符串，指定了正则表达式的模式或其他正则表达式。
参数 attributes 是一个可选的字符串，包含属性 "g"、"i" 和 "m"，分别用于指定全局匹配、区分大小写的匹配和多行匹配。ECMAScript 标准化之前，不支持 m 属性。如果 pattern 是正则表达式，而不是字符串，则必须省略该参数。

## <a href="#RegExpAttr"> RegExp 对象属性</a> <a name="RegExpAttr"></a>
	lastIndex	 一个整数，标示开始下一次匹配的字符位置。
	ignoreCase	 是否使用了'i'标记使正则匹配忽略大小写
	global	       是否使用了'g'标记来进行全局的匹配.
	multiline	 是否使用了'm'标记使正则工作在多行模式（也就是，^ 和 （$ $） 可以匹配字符串中每一行的开始和结束（行是由 \n 或 \r 分割的），而不只是整个输入字符串的最开始和最末尾处。）
	source	      正则模式的字符串，即正则表达式的源文本
	
## <a href="#RegExpFn"> RegExp 对象方法</a> <a name="RegExpFn"></a>
	compile	编译正则表达式 ,也可用于改变和重新编译正则表达式。
	exec	检索字符串中指定的值。返回找到的值，并确定其位置。
	test	      检索字符串中指定的值。返回 true 或 false。
	
1. exec ： 指定的一段字符串执行搜索匹配操作。它的返回值是一个数组或者 null；regexObj.exec(str), 如果成功匹配，exec 方法返回一个数组，并且更新正则表达式对象的属性。返回的数组包括匹配的字符串作为第一个元素，紧接着一个元素对应一个成功匹配被捕获的字符串的捕获括号（capturing parenthesis）—`括号中的分组捕获`。 
exec() 方法还返回两个属性。
	- `index 属性`声明的是匹配文本的`第一个字符的位置`。
	- `input 属性`则存放的是`被检索的字符串 string`。
	- 我们可以看得出，在调用非全局的 RegExp 对象的 exec() 方法时，返回的数组与调用方法 `String.match() 返回的数组`是相同的。
	- 注意： 如果在一个字符串中完成了一次模式匹配之后要开始检索新的字符串，就必须手动地把 lastIndex 属性重置为 0。


``` javascript
var str = "Visit W3CSchool, W3CSchool is a place to study web technology.";

var patt = new RegExp("W3CSchool","gi");

var result;
while ((result = patt.exec(str)) != null)  {
  document.write('result= '+ result + "<br />");
  document.write('index= '+ result.index + "<br />");  //exec() 方法还返回两个属性
  document.write( 'input= '+ result.input + "<br />");  //exec() 方法还返回两个属性
  document.write('lastIndex= '+ patt.lastIndex + "<br />");
}
```

	
##  <a href="#String">支持正则表达式的 String 对象的方法</a><a name="String"></a>
	search	检索与正则表达式相匹配的值,返回字符串的位置。
	match	找到一个或多个正则表达式的匹配, 返回指定的值，而不是字符串的位置。
	replace	用于在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串。	
	split	把字符串分割为字符串数组。	
	
1. match :	stringObject.match(searchvalue) / stringObject.match(regexp)
2. replace:  stringObject.replace(regexp/substr,replacement)必需。
    - regexp/substr：必需。 规定子字符串或要替换的模式的 RegExp 对象。请注意，如果该值是一个字符串，则将它作为要检索的直接量文本模式，而不是首先被转换为 RegExp 对象。
    - replacement：必需。可以是字符串，也可以是函数。规定了替换文本或生成替换文本的函数。
    - 参数replacement 可以是函数而不是字符串。在这种情况下，每个匹配都调用该函数，它返回的字符串将作为替换文本使用。该函数的第一个参数`一`是`匹配模式的字符串`。接下来的参数`二`是与模式中的`子表达式匹配的字符串`，可以有 0 个或多个这样的参数。接下来的参数`三`是一个整数，声明了匹配在 stringObject 中出现的位置。最后一个参数`四`是` stringObject 本身`。
    - 返回：一个新的字符串，是用 replacement 替换了 regexp 的第一次匹配或所有匹配之后得到的。
    - 如果 regexp `具有全局标志 g`，那么 replace() 方法将替换所有匹配的子串。否则，它只替换第一个匹配子串。

| 字符	 |     替换文本   |
| :-------  | :------------|	
| $1、$2、…、 $ 99  $| 与 regexp 中的第 1 到第 99 个子表达式相匹配的文本。|
| $&	| 与 regexp 相匹配的子串。|
| $`	      |位于匹配子串左侧的文本。|
| $'	      |位于匹配子串右侧的文本。 |
| $$	| $直接量符号。|

``` javascript
var str = 'aaa bbb ccc';
var uw= str.replace(/(\b\w+\b)/g, function(word,$,index,input){
  console.log(word);  // aaa 匹配模式的字符串
  console.log($);     // aaa 子表达式相匹配的文本
  console.log(index); // 0 一个整数，声明了匹配在 stringObject 中出现的位置,匹配到的字符位于原始字符串的基于0的索引值
  console.log(input); // aaa bbb ccc :str 本身  即原始字符串
  return word.substring(0,1).toUpperCase()+word.substring(1);}
  );

console.log(uw); // Aaa Bbb Ccc
``` 
``` javascript
var name = "Doe, John";
var reg = name.replace(/(\w+)\s*, \s*(\w+)/, "$2 $1"); // John Doe
```
3. split
	 - stringObject.split(separator,howmany)
	 - separator	必需。字符串或正则表达式，从该参数指定的地方分割 stringObject。`如果把空字符串 ("") 用作 separator，那么 stringObject 中的每个字符之间都会被分割`。
	 - howmany	可选。该参数可指定返回的数组的最大长度length。如果设置了该参数，返回的子串不会多于这个参数指定的数组。如果没有设置该参数，整个字符串都会被分割，不考虑它的长度。
	 - 返回值: 一个字符串数组。该数组是通过在 separator 指定的边界处将字符串stringObject 分割成子串创建的。返回的数组中的字串`不包括 separator 自身`。但是，如果 separator 是包含子表达式的正则表达式，那么返回的数组中包括与这些子表达式匹配的`字串`即$ $1,（但不包括与整个正则表达式匹配的文本即input）

```
var str="How are you doing today?"
console.log(str.split(""))  // H,o,w, ,a,r,e, ,y,o,u, ,d,o,i,n,g, ,t,o,d,a,y,? 每个字符串都被分割
console.log(str.split(" ",3)) // How,are,you 传入第二个参数，限定了数组的最长长度
console.log(str.split(/\s+/,3)) //与上一样
```	 
4. search 
    - stringObject.search(regexp)
    - regexp: 该参数可以是需要在 stringObject 中检索的子串，也可以是需要检索的 RegExp 对象。注释：要执行忽略大小写的检索，请追加标志 i。
    - 返回值: stringObject 中第一个与 regexp 相匹配的子串的起始位置。如果没有找到任何匹配的子串，则返回 -1。




##<a href="#execOrMatch">exec与match的异同</a> <a name="execOrMatch"></a>

1.  在调用非全局的 RegExp 对象的 exec() 方法时，返回的`数组与调用方法` 与 String.match() 返回的数组是相同的。
2. 当 RegExpObject 是一个全局正则表达式时，exec() 的行为就稍微复杂一些。它会在 RegExpObject 的 lastIndex 属性指定的字符处开始检索字符串 string。当 exec() 找到了与表达式相匹配的文本时，在匹配后，它将把 RegExpObject 的 lastIndex 属性设置为匹配文本的最后一个字符的下一个位置。这就是说，您可以通过反复调用 exec() 方法来遍历字符串中的所有匹配文本。当 exec() 再也找不到匹配的文本时，它将返回 null，并把 lastIndex 属性重置为 0。  `在循环中反复地调用 exec() 方法是唯一一种获得全局模式的完整模式匹配信息的方法`。
3. 全局匹配返回的数组的内容与前者大不相同，它的数组元素中存放的是 stringObject 中所有的匹配子串，而且也没有 index 属性或 input 属性。即在全局检索模式下，match() 即不提供与子表达式匹配的文本的信息，也不声明每个匹配子串的位置。如果您需要这些全局检索的信息，可以使用 RegExp.exec()。

## <a name="function"></a><a href="#function"> 作用 </a>
典型的搜索和替换操作要求您提供与预期的搜索结果匹配的确切文本。虽然这种技术对于对静态文本执行简单搜索和替换任务可能已经足够了，但它缺乏灵活性，若采用这种方法搜索动态文本，即使不是不可能，至少也会变得很困难。

1. 测试字符串内的模式。
例如，可以测试输入字符串，以查看字符串内是否出现电话号码模式或信用卡号码模式。这称为数据验证。
2. 替换文本。
可以使用正则表达式来识别文档中的特定文本，完全删除该文本或者用其他文本替换它。
3. 基于模式匹配从字符串中提取子字符串。
可以查找文档内或输入域内特定的文本。

例如，您可能需要搜索整个网站，删除过时的材料，以及替换某些 HTML 格式标记。在这种情况下，可以使用正则表达式来确定在每个文件中是否出现该材料或该 HTML 格式标记。此过程将受影响的文件列表缩小到包含需要删除或更改的材料的那些文件。然后可以使用正则表达式来删除过时的材料。最后，可以使用正则表达式来搜索和替换标记。

### 普通字符

普通字符包括没有显式指定为元字符的所有可打印和不可打印字符。这包括所有大写和小写字母、所有数字、所有标点符号和一些其他符号。

### 非打印字符

非打印字符也可以是正则表达式的组成部分。下表列出了表示非打印字符的转义序列：

| 字符	 |     描述   |
| :———  | :——————|
| \cx	 | 匹配由`x指明的控制字符`。例如， \cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 'c' 字符。 |
| \f	       | 匹配一个`换页符`。等价于 \x0c 和 \cL。|
| \n	       | 匹配一个`换行符`。等价于 \x0a 和 \cJ。|
| \r	       | 匹配一个`回车符`。等价于 \x0d 和 \cM。|
| \s        | 匹配任何`空白字符`，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。|
|\S	       |匹配任何非空白字符。等价于 [^ \f\n\r\t\v]。|
|\t	       | 匹配一个`制表符tap`。等价于 \x09 和 \cI。|
|\v	       | 匹配一个`垂直制表符`。等价于 \x0b 和 \cK。|

### 特殊字符

所谓特殊字符，就是一些有特殊含义的字符.

许多元字符要求在试图匹配它们时特别对待。若要匹配这些特殊字符，必须首先使字符`”转义”`，即，`将反斜杠字符 (\) 放在它们前面`。下表列出了正则表达式中的特殊字符：

| 特别字符 |  	描述 |
| :--------  | :-------- |
| ^	       | 匹配`输入字符串的开始位置`，除非在`方括号表达式`中使用，此时它表示`不接受该字符集合`。如果设置了 RegExp 对象的 Multiline 属性，^ 还会与 \n 或 \r 之后的位置匹配要匹配 ^ 字符本身，请使用 \^. |
| $ $      | 匹配输入字符串的`结尾位置`。如果设置了 RegExp 对象的 Multiline 属性，则$ $ 还会与 \n 或 \r 之前的位置匹配。要匹配 $ 字符本身，请使用 \$。|
| \*	       |`{ 0,  }`匹配前面的子表达式零次或多次。要匹配 * 字符，请使用 \*。例如，zo* 能匹配 "z" 以及 "zoo"。|
| ?	       | `{ 0, 1 }`匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。当该字符紧跟在任何一个其他限制符 (*, +, ?, {n}, {n,}, {n,m}) 后面时，匹配模式是非贪婪的。`非贪婪模式`尽可能少的匹配所搜索的字符串，而`默认的贪婪模式`则尽可能多的匹配所搜索的字符串。例如，对于字符串 "oooo"，'o+?' 将匹配单个 "o"，而 'o+' 将匹配所有 'o'。要匹配 ? 字符，请使用 \?。例如，"do(es)?" 可以匹配 "do" 或 "does" 中的"do" 。|
| \+	       |`{ 1,  }`匹配前面的子表达式一次或多次。要匹配 + 字符，请使用 \+。例如，'zo+' 能匹配 "zo" 以及 "zoo"，但不能匹配 "z"。|
| \	       | 将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。例如， 'n' 匹配字符 'n'。'\n' 匹配换行符。序列 '\\' 匹配 "\"，而 '\(' 则匹配 "("。|
| .	       | 匹配除`非换行符 \n之外的任何单字符`。要匹配 .，请使用 \。|
| ( )	       |标记一个`子表达式`的开始和结束位置。子表达式可以获取供以后使用。要匹配这些字符，请使用 \( 和 \)。获取的匹配可以从产生的 Matches 集合得到，在VBScript 中使用 SubMatches 集合，在JScript 中则使用 $0…$9 属性。
| [	       | 标记一个`中括号表达式`的开始。要匹配 [，请使用 \[。匹配所包含的任意一个字符。例如， '[abc]' 可以匹配 "plain" 中的 'a'。|
| {	       | 标记`限定符表达式`的开始。要匹配 {，请使用 \{。|
| \|	       | 指明两项之间的一个`选择`。要匹配 \|，请使用 \|。例如，'z|food' 能匹配 "z" 或 "food"。'(z|f)ood' 则匹配 "zood" 或 "food"。|
| \w	       | 查找单词字符。匹配包括下划线的任何单词字符。等价于'[A-Za-z0-9_]'。|
| \W	       |查找非单词字符。等价于 '[^A-Za-z0-9_]'。|
| \d	       |查找数字。[0-9]|
| \D       |	查找非数字字符。|
| \0	       | 查找 NUL 字符。|


子表达式与中括号表达式的区别：

1. (): 是在匹配表达式之后仍然可以提取出来  ——— $1（从1开始），[] 不可以。用圆括号将所有选择项括起来，相邻的选择项之间用|分隔。但用圆括号会有一个副作用，是相关的匹配会被`缓存`，此时可用?:放在第一个选项前来消除这种副作用。

2. []方括号用于查找某个范围内的字符

## 元字符
这里写的部分，是前面或者后面没有出现过的！已经有的不再重复

|  元字符    |  	描述 |
| :-------- | :-------- |
|\nm	 | 标识一个八进制转义值或一个向后引用。如果 \nm 之前至少有 nm 个获得子表达式，则 nm 为向后引用。如果 \nm 之前至少有 n 个获取，则 n 为一个后跟文字 m 的向后引用。如果前面的条件都不满足，若 n 和 m 均为八进制数字 (0-7)，则 \nm 将匹配八进制转义值 nm。|
| \nml	|如果 n 为八进制数字 (0-3)，且 m 和 l 均为八进制数字 (0-7)，则匹配八进制转义值 nml。|
| \un	|匹配 n，其中 n 是一个用四个十六进制数字表示的 Unicode 字符。例如， \u00A9 匹配版权符号 (?)。|

## 限定符
限定符用来指定正则表达式的一个给定组件必须要出现多少次才能满足匹配。

|  限定符     |  	描述 |
| :-------- | :-------- |
| \*	       | 见特别字符 |
| ?	       | 见特别字符|
| \+	       | 见特别字符|
| {n}	 | n 是一个非负整数。匹配确定的 n 次。例如，'o{2}' 不能匹配 "Bob" 中的 'o'，但是能匹配 "food" 中的两个 o。|
| {n,}	 | n 是一个非负整数。至少匹配n 次。例如，'o{2,}' 不能匹配 "Bob" 中的 'o'，但能匹配 "foooood" 中的所有 o。'o{1,}' 等价于 'o+'。'o{0,}' 则等价于 ‘o*’。|
| {n,m}	 |m 和 n 均为非负整数，其中n <= m。最少匹配 n 次且最多匹配 m 次。例如，"o{1,3}" 将匹配 "fooooood" 中的前三个 o。'o{0,1}' 等价于 'o?'。请注意在逗号和两个数之间不能有空格。|

注意： *、+和?限定符都是贪婪的，因为它们会尽可能多的匹配文字，只有在它们的后面加上一个?就可以实现非贪婪或最小匹配。
 
 
 
## 定位符
定位符使您能够将正则表达式固定到行首或行尾。它们还使您能够创建这样的正则表达式，这些正则表达式出现在一个单词内、在一个单词的开头或者一个单词的结尾。

定位符用来描述字符串或单词的边界，^和$ $ 分别指字符串的开始与结束，\b描述单词的前或后边界，\B表示非单词边界。

正则表达式的定位符有：

| 定位符    |  	描述 |
| :————| :-------- |
| ^	       | 见特殊字符 |
| $ $      | 见特殊字符 |
| \b	       | 匹配一个字边界，即字与空格间的位置。描述单词的前或后边界   例如：/a\b/ 匹配 a ,但不匹配all,|
| \B	       | 非字边界匹配, 非单词边界。例如：/\Bapt/ Chapter符合，aptitude则不符合|
  
 注意：不能将限定符\*，？,+等与定位点一起使用。由于在紧靠换行或者字边界的前面或后面`不能有一个以上位置`，因此不允许诸如 ^* 之类的表达式。

## 反向引用

|  元字符    |  	描述 |
| :-------- | :-------- |
| (?:pattern)	| 匹配 pattern 但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用 "或" 字符 (|) 来组合一个模式的各个部分是很有用。例如， 'industr(?:y|ies) 就是一个比 'industry|industries' 更简略的表达式。|
| (?=pattern)	 |正向预查，量词匹配任何其后紧接指定字符串 n 的字符串，即在任何匹配 pattern 的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如，'Windows (?=95|98|NT|2000)' 能匹配 "Windows 2000" 中的 "Windows" ，但不能匹配 "Windows 3.1" 中的 "Windows"。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。|
| (?!pattern)	|负向预查，量词匹配其后没有紧接指定字符串 n 的任何字符串，即在任何不匹配 pattern 的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如'Windows (?!95|98|NT|2000)' 能匹配 "Windows 3.1" 中的 "Windows"，但不能匹配 "Windows 2000" 中的 "Windows"。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。|


> 对一个正则表达式模式或部分模式两边添加圆括号将导致相关匹配存储到一个临时缓冲区中，所捕获的每个子匹配都按照在正则表达式模式中从左到右出现的顺序存储。缓冲区编号从 1 开始，最多可存储 `99 `个捕获的子表达式。每个缓冲区都可以使用 '\n' 访问，其中 n 为一个标识特定缓冲区的一位或两位十进制数。

可以使用`非捕获元字符 '?:'、'?=' 或 '?!' `来`重写捕获`，忽略对相关匹配的保存。
### 反向引用的最简单的、最有用的应用之一，是提供查找文本中`两个相同的相邻单词的匹配项`的能力,如下所示。

``` javascript
var str = ‘Is is the cost of of gasoline going up up?’;
var reg = /\b([a-z]+) \1\b/gi; 
// 两种方法
var uw1= str.replace( reg, function(word,$){
  console.log($);     // is 子表达式相匹配的文本
  return $}
);
var uw2= str.replace( reg, '$1'); 
console.log(uw1); //Is the cost of gasoline going up?
console.log(uw2); //Is the cost of gasoline going up?
```
        - 正则表达式的第二部分是对以前捕获的子匹配项的引用，即，单词的第二个匹配项正好由括号表达式匹配。\1 指定第一个子匹配项。
        - 字边界元字符确保只检测整个单词。否则，诸如"is issued"或"this is"之类的词组将不能正确地被此表达式识别。
        - 正则表达式后面的全局标记 (g) 指示，将该表达式应用到输入字符串中能够查找到的尽可能多的匹配。表达式的结尾处的不区分大小写 (i) 标记指定不区分大小写。多行标记指定换行符的两边可能出现潜在的匹配。

### 反向引用还可以将通用资源指示符 (URI) 分解为其组件。假定您想将下面的 URI 分解为协议（ftp、http 等等）、域地址和页/路径：
如网址： http://w3cschool.cn:80/jsref_obj_regexp.html

```javascript
var url = 'http://w3cschool.cn:80/jsref_obj_regexp.html#12';
var reg = /(\w+):\/\/([^/:]+)(:\d*)?([^# ]*)/gi;
var result = reg.exec(url);
console.log(result);
// ["http://w3cschool.cn:80/jsref_obj_regexp.html", "http", "w3cschool.cn", ":80", "/jsref_obj_regexp.html", index: 0, input: "http://w3cschool.cn:80/jsref_obj_regexp.html#12"] 此处input及index是exec返回的属性
console.log(reg.lastIndex); //44
for(var i = 1, len = result.length; i!=len; i++){
  console.log('result[' + i +']=' + result[i]); //遍历出子表达式匹配的字符串
  // result[1]=http
  // 第一个括号子表达式捕获 Web 地址的协议部分。该子表达式匹配在冒号和两个正斜杠前面的任何单词。
  // result[2]=w3cschool.cn
  // 第二个括号子表达式捕获地址的域地址部分。子表达式匹配 / 或 : 之外的一个或多个字符。
  // result[3]=:80
  // 第三个括号子表达式捕获端口号（如果指定了的话。该子表达式匹配冒号后面的零个或多个数字。只能重复一次该子表达式。
  // result[4]=/jsref_obj_regexp.html
  //第四个括号子表达式捕获 Web 地址指定的路径和/或页信息。该子表达式能匹配不包括 # 或空格字符的任何字符序列。
}
var str = 'http://w3cschool.cn';
reg.lastIndex = 0; //0 重置为0,不然reg.exec 返回null
var result2 = reg.exec(str);
console.log(result2);
// ["http://w3cschool.cn", "http", "w3cschool.cn", undefined, "", index: 0, input: "http://w3cschool.cn"]
console.log(reg.lastIndex); //19

```


## 运算符优先级 <a name=""></a>
正则表达式从左到右进行计算，并遵循优先级顺序，这与算术表达式非常类似。
相同优先级的从左到右进行运算，不同优先级的运算先高后低。下表从`最高到最低`说明了各种正则表达式运算符的优先级顺序：

|  运算符    |  	描述 |
| :-------- | :-------- |
| \	                              | 转义符 |
| (), (?:), (?=), []	            |圆括号和方括号|
|*, +, ?, {n}, {n,}, {n,m}	| 限定符| 
| ^, $,                            | 任何元字符、任何字符、定位点和序列（即：位置和顺序）|
| \|	                              |替换，"或"操作|

字符具有高于替换运算符的优先级，使得"m|food"匹配"m"或"food"。若要匹配"mood"或"food"，请使用括号创建子表达式，从而产生"(m|f)ood"。

## 哪些需要替换<a name="replace"></a>

## 具体实例解析
1. /<\s*(\S+)(\s[^>]*)?>[\s\S]*<\s*\/\1\s*>/    匹配 HTML 标记。


## 参考文章：
1. http://www.phpxs.com/j/regexp/1000553
2. http://w3cschool.cn/jsref_obj_regexp.html
3. https://msdn.microsoft.com/zh-cn/library/d9eze55x(v=vs.80).aspx
