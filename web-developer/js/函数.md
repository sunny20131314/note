
# 函数
Tags: function this 函数声明 函数表达式

[TOC]

## 函数声明 & 函数表达式

### 函数创建
- JavaScript 中需要创建函数的话，常见的两种方法：函数声明、函数表达式. 
- 自执行函数表达式 `IIFE`(属于函数表达式)，主要用于创建一个新的作用域，在此作用域内声明的变量不会和其它作用域内的变量冲突或混淆，大多是以匿名函数方式存在，且立即自动执行：
- JavaScript 中创建函数的话，还有另外一种方法，称为“函数构造法”：

    ```js
    function foo() {} // 方法一：函数声明

    var foo = function () {};// 方法二：函数表达式

    (function () { // var x = ...})();  // 方法三：自执行函数表达式
    
    var foo = Function('alert("hi!");');  // 函数构造法
    var foo = new Function('alert("hi!");'); // 等同于上面一行
    ```

- 方法一和方法二都创建了一个函数，且命名为 foo，但是二者还是有区别的。JavaScript 解释器中存在一种变量声明被提升（hoisting）的机制，也就是说变量（函数）的声明会被提升到作用域的最前面，即使写代码的时候是写在最后面，也还是会被提升至最前面。

- 函数名和函数的变量存在着差别。函数名不能被改变，但函数的变量却能够被再分配。函数名只能在函数体内使用。倘若在函数体外使用函数名将会导致错误（如果函数之前是通过一个var语句声明的则是undefined）。---见下方说明

```js
// foo 是函数申明： 存在变量提升
// 变量 bar, fe 存在变量提升
alert(foo); // function foo() {}  
alert(bar); // undefined

// 一个用Function构造函数定义的函数,被赋值给变量 foo:
function foo() {}

// 一个匿名函数的函数表达式,被赋值给变量 fe
var fe = function(){}; 

// 一个命名为 bar_fn 的函数的函数表达式，被赋值给变量 bar:
// 函数名 bar_fn 不能被改变，但函数的变量 bar 却能够被再分配。函数名只能在函数体内使用。
var bar = function bar_fn() {alert(bar_fn)}; 

alert(foo); // function foo() {}
alert(bar); // function bar_fn() {alert(bar_fn)}
alert(bar_fn); // 报错，没定义。 
bar();     //  弹出 function bar_fn() {alert(bar_fn)} 说明bar_fn只能在函数内部使用
```

- JavaScript 引擎执行以上代码的顺序
创建变量 foo 和 bar，并将它们都赋值为 undefined。
创建函数 foo 的函数体，并将其赋值给变量 foo。
执行前面的两个 alert。
创建函数 bar_fn，并将其赋值给 bar。

### 函数声明转换
- 函数声明非常容易（经常是意外地）转换为函数表达式。当它不再是一个函数声明：
    - 成为表达式的一部分。
    - 不再是函数或者script自身的“源元素” （source element）。在script或者函数体内“源元素”并非是内嵌的语句（statement）。

```js
var x = 0;               // source element
if (x == 0) {            // source element
   x = 10;               // 非source element
   function boo() {}     // 非 source element
}
function foo() {         // source element
   var y = 20;           // source element
   function bar() {}     // source element
   while (y == 10) {     // source element
      function blah() {} // 非 source element
      y++;               //非source element
   }
}

// 函数声明
function foo() {}

// 函数表达式
(function bar() {})

// 函数表达式
x = function hello() {}

if (x) {
   // 函数表达式
   function world() {}
}

// 函数声明
function a() {
   // 函数声明
   function b() {}
   if (0) {
      //函数表达式
      function c() {}
   }
}
```

- 下面的zero函数看起来像是函数声明，但它实际上是表达式（或者语句），因为它是内嵌于另外一个语句当中的。来看看函数声明和函数表达式之间的不同。
- 函数可以被有条件来声明，这意味着，在一个 if 语句里，函数声明是可以嵌套的。一些JavaScript引擎， SpiderMonkey除外，不能正确地处理任何带有名称的函数表达式的函数定义，这将导致即使条件结果永远为false，而zero函数都会被定义。（不要把这种不确定抛给浏览器处理，能避免则避免）
    - 也就是说，一些JavaScript引擎会将这种有条件的声明看成是无条件的声明，无论这里的条件是true还是false，浏览器都会创建函数。因此，它们不应该被使用。
- 有条件地定义一个函数的一个更安全的方法是定义一个匿名函数并将它赋值给一个变量：zero2

```js
// 在下面的script中，zero函数永远不会被定义和调用，因为'if (0)'的运算结果是false，但是在一些JavaScript引擎，即使条件结果永远为false，而zero函数都会被定义。

if (0) {
   function zero() { 
      document.writeln("This is zero.");
   }
}

if (0) {
   var zero2 = function() {
      document.writeln("This is zero.");
   }
}
```

### 分辨函数申明和函数表达式
综上所述，当在函数体内或者全局环境下的函数声明依然是函数声明，其余会转换为函数表达式！！！


## js 调用
js 里函数调用有 4 种模式：

- 方法调用、正常函数调用、构造器函数调用、apply/call 调用。
- 同时，无论哪种函数调用除了你声明时定义的形参外，还会自动添加 2 个形参，分别是 this 和 arguments。

## 改变this指向
### apply & call 

- apply接收 2 个参数，第一个是传递给这个函数用来绑定 this 的值，第二个是一个参数`数组`。
- call() ，它的第一个参数也是绑定给 this 的值，但是后面接受的是不定参数，而不再是一个数组，也就是说你可以像平时给函数传参那样把这些参数一个一个传递。
    - 如果apply & call第一个参数传递 null，那么在函数 a 里面 this 指针依然会绑定全局对象 window。
    - 立马就调用了对应的函数。
	
	```js
	function a(xx, yy) {    
	    console.log(xx, yy);    
	    console.log(this);    
	    console.log(arguments);
	}
	
	var o = {};
	a.apply(o, [5, 55]); 
	a.call(o, 5, 55);
	// 5 55
	// Object {}
	// [5, 55]
	
	a.apply(null, [5, 55]);
	a.call(null, 5, 55);
	// 5 55
	// Window {…}
	// [5, 55]
	
	```

### bind
- bind() 会生成一个新的函数.
- bind() 函数的参数跟 `call() `一致，第一个参数也是绑定 this 的值，后面接受传递给函数的不定参数。 
- bind() 生成的新函数返回后，你想什么时候调就什么时候调

```js
var m = {   
  x : 1
};
function foo(y) {
  alert(this.x + y);
}
foo.apply(m, [5]);  // 6
foo.call(m, 5);

var foo1 = foo.bind(m, 5);
foo1();    // 6
```




## 参考
1. http://rangercyh.blog.51cto.com/1444712/1615809