# 数组

[TOC]

## 在对象数组中找相应的index
```js
// 看当前值val 是对应的数组arr中的对象的属性值attr  具体index
Array.prototype.findIndexInArrObj = function(val, attr ) {
    var arr = this;
    if( !val ){
      return;
    }
    attr = attr || 'name';
    for( var m = 0; m != arr.length; m++ ){
      if( val === arr[m][attr] ){
        return m >= 0 ? m : '';
      }
    }
  };
```

## Object.keys
1.  可以返回数字键名

    ```js
    var a = [1,2,3]; a.key = 'NAN'; 
    Object.keys(a);
    //["0", "1", "2", "key"]
    ```
2.  

## undefined 与空位的区别
### 空位
1. 当数组的某个位置是空元素，即两个逗号之间没有任何值，我们称该数组存在空位（hole）。
    - 如果最后一个元素后面有逗号，并不会产生空位。也就是说，有没有这个逗号，结果都是一样的。
    - var a = [1,2,3,];ie8及以下其length是4；标准浏览器下length是3；

    ```js
    var a = [1, , 1, ];
    a.length // 3
    ```

2. 数组的空位是可以读取的，返回undefined。
3. delete命令
    - 使用delete命令删除一个值，会形成空位。
    - delete命令不影响length属性。
    - length属性不过滤空位。所以，使用length属性进行数组遍历，一定要非常小心。
4. 如果是空位，使用数组的forEach方法、for...in结构、以及Object.keys方法进行遍历，空位都会被跳过。

    ```js
    var a = [, , ,];
    
    a.forEach(function (x, i) {
      console.log(i + '. ' + x);
    })
    // 不产生任何输出
    
    for (var i in a) {
      console.log(i);
    }
    // 不产生任何输出
    
    Object.keys(a);
    // []
    ```

### undefined
1. 如果某个位置是undefined，遍历的时候就不会被跳过。

    ```js
    var a = [undefined, undefined, undefined];
    
    a.forEach(function (x, i) {
      console.log(i + '. ' + x);
    });
    // 0. undefined
    // 1. undefined
    // 2. undefined
    
    for (var i in a) {
      console.log(i);
    }
    // 0
    // 1
    // 2
    
    Object.keys(a)
    // ['0', '1', '2']
    ```

### 区别：
空位就是数组没有这个元素，所以不会被遍历到，而undefined则表示数组有这个元素，值是undefined，所以遍历不会跳过。



## findIndex

```js
	if (!Array.prototype.indexOf) {  // < ie9
	  Array.prototype.indexOf = function(elt) {
	    var len = this.length ;
	    var from = Number(arguments[1]) || 0;
	    from = (from < 0) ? Math.ceil(from) : Math.floor(from);
	    // 第二个参数可能为负
	    if (from < 0)
	      from += len;
	    for (; from < len; from++) {
	      if (from in this && this[from] === elt)
	        return from;
	    }
	    return -1;
	  };
	}

  if (!Array.prototype.findIndex) {
    Array.prototype.findIndex = function(predicate) {
      if (this === null) {
        throw new TypeError('Array.prototype.findIndex called on null or undefined');
      }
      if (typeof predicate !== 'function') {
        throw new TypeError('predicate must be a function');
      }
      var list = Object(this);
      var length = list.length >>> 0;
      var thisArg = arguments[1];
      var value;

      for (var i = 0; i < length; i++) {
        value = list[i];
        if (predicate.call(thisArg, value, i, list)) {
          return i;
        }
      }
      return -1;
    };
  }
```