## 垃圾回收机制:

常说的机制有两种:
1, 引用清除.
> 该算法限制：循环引用: 这个简单的算法有一个限制，就是如果一个对象引用另一个（形成了循环引用），他们可能“不再需要”了，但是他们不会被回收。
 
  - 此算法把“对象是否不再需要”简化定义为“对象有没有其他对象引用到它”。
  - 计算变量的引用次数,当引用次数为0时,没有引用指向该对象（零引用），对象将被垃圾回收机制回收。
  
1, 标记清除.
  
> 这个算法比引用清除要好，因为“有零引用的对象”总是不可获得的，但是相反却不一定，参考“循环引用”。

  - 一开始运行的时候,内存中的所有变量都被标记,然后进入环境中和被环境所引用的变量(闭包)标记被清除.
  - 之后仍有标记的变量被视为准备删除的变量,原因是环境中的变量已经无法访问到这些变量了.
  - 最后，垃圾回收器完成内存清除工作，销毁那些带标记的值并回收它们所占用的内存空间。
  
  标记-清除算法（2012年后所有现代浏览器都使用该算法）：
   
   - 这个算法把“对象是否不再需要”简化定义为“对象是否可以获得”。
   - 这个算法假定设置一个叫做根的对象（在Javascript里，根是全局对象）。
   - 定期的，垃圾回收器将从根开始，找所有从根开始引用的对象，然后找这些对象引用的对象(从根开始，垃圾回收器将找到所有可以获得的对象和所有不能获得的对象。）

从2012年起，所有现代浏览器都使用了标记-清除垃圾回收算法。所有对JavaScript垃圾回收算法的改进都是基于标记-清除算法的改进，并没有改进标记-清除算法本身和它对“对象是否不再需要”的简化定义。

1, 函数调用返回之后，两个对象从全局对象出发无法获取。因此，他们将会被垃圾回收器回收。
 2,一旦 div 和其事件处理无法从根获取到，他们将会被垃圾回收器回收  
## 参考
1. https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Memory_Management