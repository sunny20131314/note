## 一次完整的HTTP事务
### 基本流程：
1.  [域名解析](#域名解析)


### [FPS](#fps)
### 基本流程：

a. <a name="域名解析"> 域名解析</a>( DNS 解析域名为ip, 域名ip映射表 )
  - 客户端发送请求访问 www.haha.cn 到DNS域名解析器.
  - DNS 解析: 先找到root DNS,查询域名的授权服务器. -> 查询域名的ip地址 -> 向智能调度DNS查询 ->
  根据`网络流量`和`各节点的连接`、`负载状况`以及到用户的` 距离`等,将最适合的CDN节点ip地址回应给 LocalDns.
    -> cdn溯源: 发送请求时,文件不存在则往总服务器上找!!!

b. 发起TCP的3次握手

c. 建立TCP连接后发起http请求

d. 服务器端响应http请求，浏览器得到html代码

e. 浏览器解析html代码，并请求html代码中的资源

f. 浏览器对页面进行渲染呈现给用户.
 
  * [页面的渲染](http://web.jobbole.com/84843/):
  dom,cssom: Bytes -> characters(字,符号) -> tokens(startTag:html, startTag:head) -> nodes -> object Model
     - create/update 边下载边自上而下解析html文件构建为dom树,并并行发送请求  -> css,js,图片
     - create/update render cssom (css加载完成,开始构建cssom)
     - create/update render tree (渲染树构建) 网页中的节点,各个节点的css定义及从属关系
        - display:none, 不会解析到render tree 中
     - layout(布局): 生成布局计算每个节点在屏幕中的位置
     - painting: 渲染树绘制

 * 网页生成的时候，至少会渲染一次。用户访问的过程中，还会不断重新渲染。重新渲染，就需要重新生成布局和重新绘制。前者叫做"重排"（reflow），后者叫做"重绘"（repaint）。

    -  修改DOM
    -  修改样式表
    -  用户事件（比如鼠标悬停、页面滚动、输入框键入文字、改变窗口大小等等）
 * 重排和重绘（重新生成布局和重新绘制）紫色`rendering`：样式计算和布局，即重排
绿色`painting`：
 	1. «重绘"不一定需要"重排"，重绘比如改变某个网页元素的颜色，就只会触发"重绘"，不会触发"重排"，因为布局没有改变。但是，"重排"必然导致"重绘"，比如改变一个网页元素的位置，就会同时触发"重排"和"重绘"，因为布局改变了。 
 	2.  浏览器已经很智能了，会尽量把所有的变动集中在一起，排成一个队列，然后一次性执行，尽量避免多次重新渲染。
 	3. 从性能角度考虑，尽量不要把读操作和写操作，放在一个语句里面。这样就可以让css变动放在一次执行！
 	4.  样式表越简单，重排和重绘就越快。
重排和重绘的DOM元素层级越高，成本就越高。
table元素的重排和重绘成本，要高于div元素

#### 所以从性能上的优化点：
第一条是上一节说到的，DOM 的多个读操作（或多个写操作），应该放在一起。不要两个读操作之间，加入一个写操作。

```
div.style.left = div.offsetLeft + 10 + "px";
div.style.top = div.offsetTop + 10 + "px";

```

第二条，如果某个样式是通过重排得到的，那么最好缓存结果。避免下一次用到的时候，浏览器又要重排。

第三条，不要一条条地改变样式，而要通过改变class，或者csstext属性，一次性地改变样式。

```
el.className += " theclassname";

el.style.cssText += "; left: " + left + "px; top: " + top + "px;";
```

第四条，尽量使用离线DOM，而不是真实的网面DOM，来改变元素样式。比如，操作Document Fragment对象，完成后再把这个对象加入DOM。再比如，使用 cloneNode() 方法，在克隆的节点上进行操作，然后再用克隆的节点替换原始节点。

第五条，先将元素设为display: none（需要1次重排和重绘），然后对这个节点进行100次操作，最后再恢复显示（需要1次重排和重绘）。这样一来，你就用两次重新渲染，取代了可能高达100次的重新渲染。

第六条，position属性为absolute或fixed的元素，重排的开销会比较小，因为不用考虑它对其他元素的影响。

第七条，只在必要的时候，才将元素的display属性为可见，因为不可见的元素不影响重排和重绘。另外，visibility : hidden的元素只对重绘有影响，不影响重排。

第八条，使用虚拟DOM的脚本库，比如React等。

第九条，使用 window.requestAnimationFrame()、window.requestIdleCallback() 这两个方法调节重新渲染（详见后文）。

 
###  <a name="fps">FPS</a>
> 一秒之间能够完成多少次重新渲染，这个指标就被称为"刷新率"，英文为`FPS`（frame per second）。60次重新渲染，就是60FPS。一秒之内进行60次重新渲染，每次重新渲染的时间不能超过16.66毫秒。

> 网页动画的每一帧（frame）都是一次重新渲染。每秒低于24帧的动画，人眼就能感受到停顿。一般的网页动画，需要达到每秒30帧到60帧的频率，才能比较流畅。

> 如果想达到60帧的刷新率，就意味着JavaScript线程每个任务的耗时，必须少于16毫秒。一个解决办法是使用Web Worker，主线程只用于UI渲染，然后跟UI渲染不相干的任务，都放在Worker线程。




