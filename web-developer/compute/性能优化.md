# 性能优化

## `网络上的优化`
  1. [使用CDN内容分发网络托管](#CDN),
  2. [文件合并并压缩,包括图片--使用图片精灵](#compress)
  3. [设置缓存](#缓存),
  4. [懒加载,](#lozyload)
  5. [css样式的定义放置在html文件的head内-Javascript脚本放在文件末尾](#put)
  6. [使用多域名负载网页内的多个文件、图片](#多域名)
  7. [要减少对外部JavaScript、CSS、图片等资源的引用](#少域名)

## [`html,css,js`的性能优化](#内容优化)

## `网络上的优化`
1, <a name="CDN"></a>使用CDN内容分发网络托管
  -其基本思路是尽可能避开互联网上有可能影响数据传输
  *`速度和稳定性`*的瓶颈和环节，使内容传输的更快、更稳定。
  通过在网络各处放置`节点服务器`所构成的在现有的互联网基础之上的一层`智能虚拟网络`，
  CDN系统能够实时地根据`网络流量`和`各节点的连接`、`负载状况`以及到用户的` 距离`等综合信息
  将用户的请求重新导向离用户最近的服务节点上。
  其目的是使用户可就近取得所需内容，解决 Internet网络拥挤的状况，提高用户访问网站的`响应速度`。


2, <a name="compress"></a>文件合并并压缩,包括图片--使用图片精灵
  
  - 代码合并可以减少文件数量,可以减少发送http请求的次数
  - 压缩是为了减小文件的大小
  - 压缩的话,还可以放在服务器端,
 
  1, 在一般场景下,我们可以手动使用一些工具对代码进行压缩合并,script标签放在文件底部,这也是各方面性能都比较好的一种方式.

  2, 但在多人合作,即使每个人把代码按照约定的规则,合并之后的代码并不是那个顺序,可能一个楼层一个css,js,
    还有在一些页面是一个个模块组成,是由后端把代码拼凑在一块时,并不是前端可以控制的范围,合并之后也是顺序不定.
    那么页面的渲染及性能就会受到影响,还有就是你修改了一个页面,就需要手动再压缩一次.

  3, 在服务器端一旦获取到html文件,就对文件解析,把其中的需要css,js
    分别拼接放在一个文件中,然后再把修改过的html(其中路径重新指向)发给客户端,
    可以有效的减少请求次数,并优化了性能,js依然在底部.缺点是需要消耗一些时间.


3, <a name="缓存">	设置缓存</a>
  - http服务端设置:本地缓存阶段,协商缓存阶段,`缓存失败阶段`
    - 新鲜度（过期机制）: `本地缓存阶段`, 如果发现文件有效,没有过期,则继续使用本地缓存,不发送http请求
      - Expires,

      - cache-control,如果设了max-age，max-age就会覆盖expires。如果expires到期需要重新请求。是http 1.1中为了弥补 Expires 缺陷新加入的。
      对已缓存的内容进行控制：
      Cache-control: public表示缓存的版本可以被代理服务器或者其他中间服务器识别。
      Cache-control: private意味着这个文件对不同的用户是不同的。只有用户自己的浏览器能够进行缓存，公共的代理服务器不允许缓存。
      Cache-control: no-cache意味着文件的内容不应当被缓存。这在搜索或者翻页结果中非常有用，因为同样的URL，对应的内容会发生变化。
      其他相关控制字段：
      max-age: 指定缓存过期的相对时间秒数，max-ag=0或者是负值，浏览器会在对应的缓存中把Expires设置为1970-01-01 08:00:00 。
      s-maxage: 类似于max-age，只用在共享缓存上，比如proxy.
      public: 通常情况下需要http身份验证的情况，响应是不可cahce的，加上public可以使它被cache。
      no-cache: 强制浏览器在使用cache拷贝之前先提交一个http请求到源服务器进行确认。这对身份验证来说是非常有用的,能比较好的遵守 (可以结合public进行考虑)。它对维持一个资源总是最新的也很有用，与此同时还不完全丧失cache带来的好处)，因为它在本地是有拷贝的，但是在用之前都进行了确认，这样http请求并未减少，但可能会减少一个响应体。
      no-store: 告诉浏览器在任何情况下都不要进行cache，不在本地保留拷贝。
      must-revalidate: 强制浏览器严格遵守你设置的cache规则。
      proxy-revalidate: 强制proxy严格遵守你设置的cache规则。
      用法举例: Cache-Control: max-age=3600, must-revalidate
      `cache:使用本地缓存，不发生请求。`

    - 校验值（验证机制）: `协商缓存阶段`, 在本地找到文件,但是不知道文件是否过期或者已经过期,会发送http请求给服务器,
    服务器判断这个请求,没有没有改动,则返回304,让浏览器使用本地找到的那个资源.
      - last-modified,(if-modified-since)

      - e-Tags,(If-None-Match),Etag 主要为了解决 Last-Modified 无法解决的一些问题：

      1,一些文件也许会周期性的更改，但是他的内容并不改变(仅仅改变的修改时间)，这个时候我们并不希望客户端认为这个文件被修改了，而重新GET；

      2、某些文件修改非常频繁，比如在秒以下的时间内进行修改，(比方说1s内修改了N次)，If-Modified-Since能检查到的粒度是s级的，这种修改无法判断(或者说UNIX记录MTIME只能精确到秒)；

      3、某些服务器不能精确的得到文件的最后修改时间。

  -  HTML页面的Meta标签
  -  在文件的后缀(css,js后面)可以附加特征参数方式,
  参数不变化则浏览器会直接从缓存中获取副本并渲染,变化则重新下载文件或者更新信息.

4, <a name="lozyload">懒加载</a>包括html的懒加载和图片的懒加载

5, <a name="put"></a>css样式的定义放置在html文件的head内,Javascript脚本放在文件末尾(js放在body内的底部).

6, <a name="多域名"></a>使用多域名负载网页内的多个文件、图片(一个域名下可以并行发送请求是有限的,多个域名,可以更多并行下载)

7, <a name="少域名">减少域名查询</a>
   DNS查询和解析域名也是消耗时间的，所以要减少对外部JavaScript、CSS、图片等资源的引用，不同域名的使用越少越好



## <a name="内容优化">`html,css,js`的性能优化!</a>

#### html:
	1, 尽可能的使用语义化标签,有利于爬虫收集信息.
	
	2, 减少无意义的div,span和标签嵌套.
	
	3, 不适用纯样式标签，如：b、font、u等，改用css设置
	
	4, 使用表格时，标题要用caption，表头用thead，主体部分用tbody包围，
	尾部用tfoot包围。表头和一般单元格要区分开，表头用th，单元格用td；
	
	5, 结构行为表现层分离
	

#### css:
	1. 命名空间,减少样式冲突覆盖,(可使用前缀).
	
	2. 使用缩写,但要注意样式覆盖的问题.
	
	3. 权重！权重！！权重！！！正所谓马太效应，如果你写了很烂的 css，这段烂代码的不好之处是他会导致更多和更烂的代码。
	
	4. 注意使用 id： id 的高权重特性意味着滥用 id 绝对是一个很糟的做法！
	
	5. 使用使用大串的 css 选择器（多层级），后续要覆盖样式很麻烦。
	
	6. 尽量少使用Inline styles：
	  - 内联样式是css 权重罪恶的源泉，同时也从根本上摧毁了我们使用 css 的初心（结构样式分离）。
	  - 根据 css 权重级的特性，内联样式只能被!important 所覆盖。
	  - 的确!important在 css 样式表中用起来十分方便，但我们最好是聪明地、小心翼翼地碰她、用他，而不是把他当做救命稻草（救命稻草用多了，迟早也会从救命稻草变成压死骆驼的稻草）。
	
	7. 避免冗余/重复

	8. 向下兼容和无效的规则
	
	9. (没有意义)不起作用的样式
	
	10.  巧而不巧:用 Hack 不意味着你是个好 Hacker
	   - 任何时候你意识到你写了一个 css 的 hack 用法的时候，你直接把这些代码放到这个hack.css 之中（或者样式表的特定区域：通过注释跟其他样式区分开），这个专属区域是个好解决方案因为他最终会在用户端隐藏。
	
	11.  糟糕的文档和注释, 


 
	




#### js:
	1, 尽可能的减少全局变量,多使用局部变量.
	
	2, 命名空间, 减少变量和函数声明冲突覆盖.
	
	3, 小心使用闭包,避免多层嵌套.
	  - 闭包会使引用的变量不会被 GC垃圾回收机制 回收,而一直存在内存中.在IE中可能导致内存泄露。
	  解决方法是，在退出函数之前，将不使用的局部变量全部删除。
	  - 内存泄露: 不需要的变量,不会被GC回收,而一直保存在内存中.
	
	4, 尽可能的减少dom操作,每一次DOM操作都会导致页面重新渲染.
	
	5, 不需要的变量, 使用过后把它删除(对象指针null, 数组的length=0).
	
	6, 常用的dom对象,可以保存在变量中,减少了每次去查找的时间.


## 参考文章：
1. http://www.jianshu.com/p/jG8GEu
